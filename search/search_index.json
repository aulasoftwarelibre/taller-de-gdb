{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros manuales libres que pueden encontrarse en la secci\u00f3n de Referencias . Contenido \u00b6 Inicio \u00bfQu\u00e9 es GDB? Referencias Agradecimientos \u00b6 Este curso ha sido impartido por las siguientes personas: Sergio G\u00f3mez Licencia \u00b6 El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Home"},{"location":"#contenido","text":"Inicio \u00bfQu\u00e9 es GDB? Referencias","title":"Contenido"},{"location":"#agradecimientos","text":"Este curso ha sido impartido por las siguientes personas: Sergio G\u00f3mez","title":"Agradecimientos"},{"location":"#licencia","text":"El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Licencia"},{"location":"about/","text":"\u00bfQu\u00e9 es un depurador? \u00b6 Los depuradores son herramientas que permiten analizar el comportamiento o detectar fallos en una aplicaci\u00f3n software. Son, por tanto, una herramienta imprescindible para los desarrolladores y aprender a utilizarlos se considera algo b\u00e1sico. Funciones de los depuradores \u00b6 Gracias a los depuradores, podremos realizar una serie de operaciones mientras analizamos una aplicaci\u00f3n que hayamos desarrollado y de la que tengamos el c\u00f3digo fuente, tales como: Ejecuci\u00f3n paso a paso. Interrupci\u00f3n de la ejecuci\u00f3n en un punto determinado o por eventos. Trazar (tracking) las funciones por las que hemos pasado. Visualizar el valor de las variables. Ejecutar expresiones. Modificar el estado de la aplicaci\u00f3n. Localizar fugas de memoria (memory leaks). Entre un largo etc\u00e9tera. GDB \u00b6 En este curso nos vamos a enfocar en GDB. GDB o GNU Debugger es un depurador desarrollado inicialmente por Richard Stallman como parte del proyecto GNU, que funciona con m\u00faltiples lenguajes de programaci\u00f3n tales como C, C++, Fortran o Go, entre otros. La instalaci\u00f3n es directa con el gestor de paquetes de nuestra distribuci\u00f3n de Linux. 1 2 3 4 5 # Distribuciones basadas en Debian (deb/apt) apt-get install gdb # Distribuciones basadas en RedHat (rpm/yum) yum install gdb En los siguientes cap\u00edtulos desarrollaremos un ejemplo, donde incorporaremos una serie de errores, e iremos depurando la aplicaci\u00f3n paso a paso.","title":"\u00bfQu\u00e9 es un depurador?"},{"location":"about/#que-es-un-depurador","text":"Los depuradores son herramientas que permiten analizar el comportamiento o detectar fallos en una aplicaci\u00f3n software. Son, por tanto, una herramienta imprescindible para los desarrolladores y aprender a utilizarlos se considera algo b\u00e1sico.","title":"\u00bfQu\u00e9 es un depurador?"},{"location":"about/#funciones-de-los-depuradores","text":"Gracias a los depuradores, podremos realizar una serie de operaciones mientras analizamos una aplicaci\u00f3n que hayamos desarrollado y de la que tengamos el c\u00f3digo fuente, tales como: Ejecuci\u00f3n paso a paso. Interrupci\u00f3n de la ejecuci\u00f3n en un punto determinado o por eventos. Trazar (tracking) las funciones por las que hemos pasado. Visualizar el valor de las variables. Ejecutar expresiones. Modificar el estado de la aplicaci\u00f3n. Localizar fugas de memoria (memory leaks). Entre un largo etc\u00e9tera.","title":"Funciones de los depuradores"},{"location":"about/#gdb","text":"En este curso nos vamos a enfocar en GDB. GDB o GNU Debugger es un depurador desarrollado inicialmente por Richard Stallman como parte del proyecto GNU, que funciona con m\u00faltiples lenguajes de programaci\u00f3n tales como C, C++, Fortran o Go, entre otros. La instalaci\u00f3n es directa con el gestor de paquetes de nuestra distribuci\u00f3n de Linux. 1 2 3 4 5 # Distribuciones basadas en Debian (deb/apt) apt-get install gdb # Distribuciones basadas en RedHat (rpm/yum) yum install gdb En los siguientes cap\u00edtulos desarrollaremos un ejemplo, donde incorporaremos una serie de errores, e iremos depurando la aplicaci\u00f3n paso a paso.","title":"GDB"},{"location":"code/","text":"C\u00f3digo de la aplicaci\u00f3n \u00b6 A continuaci\u00f3n mostramos una posible implementaci\u00f3n de lo solicitado. Copia el contenido y guardalo en dos ficheros con el nombre que se indica en la cabecera. Tip En la esquina superior derecha de cada caja de texto con el c\u00f3digo, ver\u00e1s un icono que te copiar\u00e1 el texto al portapeles. Tip Aritm\u00e9tica de punteros Las expresiones con punteros se muestran con aritm\u00e9tica de punteros en vez de con el operador [] . Para pasar de un m\u00e9todo a otro recuerda que: x[i] equivale a *(x + i) ; es decir, a la variable le sumas el \u00edndice (para obtener la direcci\u00f3n de memoria del elemento n-\u00e9simo) y entre par\u00e9ntesis pones el operador * (para obtener el contenido de a donde apunta la direcci\u00f3n de memoria). Si el array es multidimensional repite el proceso de fuera a dentro: x[i][j] *(x[i] + j) *(*(x + i) + j) Para hacer el ejercicio opuesto, empieza por el interior. Fichero: matrix.h \u00b6 1 2 3 4 5 6 7 8 9 10 #ifndef _MATRIX_H_ #define _MATRIX_H_ int ** allocMatrix ( int n_rows , int n_columns ); void fillMatrix ( int ** matrix , int n_rows , int n_columns ); void printMatrix ( int ** matrix , int n_rows , int n_columns ); int ** removeRow ( int ** matrix , int n_rows , int n_columns , int index_to_remove ); void freeMatrix ( int *** matrix , int n_rows ); #endif // _MATRIX_H_ Fichero: matrix.c \u00b6 Warning El c\u00f3digo tiene errores de forma intencionada para poder arreglarlos en los siguientes cap\u00edtulos. De todas maneras, desde el Aula no recomendamos nunca desarrollar una aplicaci\u00f3n totalmente sino ir implementando y probando funci\u00f3n a funci\u00f3n, siguiendo la metodolog\u00eda TDD. Pero la parte de desarrollo orientada a pruebas est\u00e1 fuera del alcance de este taller. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include <stdio.h> #include <stdlib.h> #include \"matrix.h\" #define ROWS 5 #define COLUMNS 5 int main () { int ** matrix = NULL ; matrix = allocMatrix ( ROWS , COLUMNS ); fillMatrix ( matrix , ROWS , COLUMNS ); printf ( \"Matriz completa: \\n \" ); printMatrix ( matrix , ROWS , COLUMNS ); int ** newMatrix = NULL ; newMatrix = removeRow ( matrix , ROWS , COLUMNS , 1 ); printf ( \"Matriz sin la segunda fila: \\n \" ); printMatrix ( newMatrix , ROWS -1 , COLUMNS ); freeMatrix ( & newMatrix , ROWS -1 ); freeMatrix ( & matrix , ROWS ); return 0 ; } int ** allocMatrix ( int n_rows , int n_columns ) { int ** matrix = NULL ; matrix = calloc ( sizeof * matrix , n_rows ); for ( int i = 0 ; i < n_rows ; i ++ ) { * ( matrix + i ) = calloc ( sizeof ** matrix , n_columns ); } return matrix ; } void fillMatrix ( int ** matrix , int n_rows , int n_columns ) { for ( int i = 0 ; i < n_rows ; i ++ ) { for ( int j = 0 ; i < n_columns ; j ++ ) { * ( * ( matrix + i ) + j ) = - i + j ; } } } void printMatrix ( int ** matrix , int n_rows , int n_columns ) { printf ( \"Imprimiendo matrix... \\n \" ); for ( int i = 0 ; i < n_rows ; i ++ ) { for ( int j = 0 ; j < n_columns ; j ++ ) { printf ( \"%2d \" , * ( * matrix + i ) + j ); } printf ( \" \\n \" ); } printf ( \"Hecho \\n\\n \" ); } int ** removeRow ( int ** matrix , int n_rows , int n_columns , int index_to_remove ) { if ( n_rows <= 1 ) { return NULL ; } int ** newMatrix = NULL ; newMatrix = allocMatrix ( n_rows - 1 , n_columns ); int orig_row = 0 ; for ( int i = 0 ; i < n_rows - 1 ; i ++ ) { for ( int j = 0 ; j < n_columns ; j ++ ) { orig_row = i < index_to_remove ? i : i - 1 ; * ( * ( newMatrix + i ) + j ) = * ( * ( matrix + orig_row ) + j ); } } return newMatrix ; } void freeMatrix ( int *** matrix , int n_rows ) { for ( int i = 0 ; i < n_rows ; i ++ ) { free ( * (( * matrix ) + i )); * (( * matrix ) + i ) = NULL ; } * matrix = NULL ; }","title":"C\u00f3digo de la aplicaci\u00f3n"},{"location":"code/#codigo-de-la-aplicacion","text":"A continuaci\u00f3n mostramos una posible implementaci\u00f3n de lo solicitado. Copia el contenido y guardalo en dos ficheros con el nombre que se indica en la cabecera. Tip En la esquina superior derecha de cada caja de texto con el c\u00f3digo, ver\u00e1s un icono que te copiar\u00e1 el texto al portapeles. Tip Aritm\u00e9tica de punteros Las expresiones con punteros se muestran con aritm\u00e9tica de punteros en vez de con el operador [] . Para pasar de un m\u00e9todo a otro recuerda que: x[i] equivale a *(x + i) ; es decir, a la variable le sumas el \u00edndice (para obtener la direcci\u00f3n de memoria del elemento n-\u00e9simo) y entre par\u00e9ntesis pones el operador * (para obtener el contenido de a donde apunta la direcci\u00f3n de memoria). Si el array es multidimensional repite el proceso de fuera a dentro: x[i][j] *(x[i] + j) *(*(x + i) + j) Para hacer el ejercicio opuesto, empieza por el interior.","title":"C\u00f3digo de la aplicaci\u00f3n"},{"location":"code/#fichero-matrixh","text":"1 2 3 4 5 6 7 8 9 10 #ifndef _MATRIX_H_ #define _MATRIX_H_ int ** allocMatrix ( int n_rows , int n_columns ); void fillMatrix ( int ** matrix , int n_rows , int n_columns ); void printMatrix ( int ** matrix , int n_rows , int n_columns ); int ** removeRow ( int ** matrix , int n_rows , int n_columns , int index_to_remove ); void freeMatrix ( int *** matrix , int n_rows ); #endif // _MATRIX_H_","title":"Fichero: matrix.h"},{"location":"code/#fichero-matrixc","text":"Warning El c\u00f3digo tiene errores de forma intencionada para poder arreglarlos en los siguientes cap\u00edtulos. De todas maneras, desde el Aula no recomendamos nunca desarrollar una aplicaci\u00f3n totalmente sino ir implementando y probando funci\u00f3n a funci\u00f3n, siguiendo la metodolog\u00eda TDD. Pero la parte de desarrollo orientada a pruebas est\u00e1 fuera del alcance de este taller. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include <stdio.h> #include <stdlib.h> #include \"matrix.h\" #define ROWS 5 #define COLUMNS 5 int main () { int ** matrix = NULL ; matrix = allocMatrix ( ROWS , COLUMNS ); fillMatrix ( matrix , ROWS , COLUMNS ); printf ( \"Matriz completa: \\n \" ); printMatrix ( matrix , ROWS , COLUMNS ); int ** newMatrix = NULL ; newMatrix = removeRow ( matrix , ROWS , COLUMNS , 1 ); printf ( \"Matriz sin la segunda fila: \\n \" ); printMatrix ( newMatrix , ROWS -1 , COLUMNS ); freeMatrix ( & newMatrix , ROWS -1 ); freeMatrix ( & matrix , ROWS ); return 0 ; } int ** allocMatrix ( int n_rows , int n_columns ) { int ** matrix = NULL ; matrix = calloc ( sizeof * matrix , n_rows ); for ( int i = 0 ; i < n_rows ; i ++ ) { * ( matrix + i ) = calloc ( sizeof ** matrix , n_columns ); } return matrix ; } void fillMatrix ( int ** matrix , int n_rows , int n_columns ) { for ( int i = 0 ; i < n_rows ; i ++ ) { for ( int j = 0 ; i < n_columns ; j ++ ) { * ( * ( matrix + i ) + j ) = - i + j ; } } } void printMatrix ( int ** matrix , int n_rows , int n_columns ) { printf ( \"Imprimiendo matrix... \\n \" ); for ( int i = 0 ; i < n_rows ; i ++ ) { for ( int j = 0 ; j < n_columns ; j ++ ) { printf ( \"%2d \" , * ( * matrix + i ) + j ); } printf ( \" \\n \" ); } printf ( \"Hecho \\n\\n \" ); } int ** removeRow ( int ** matrix , int n_rows , int n_columns , int index_to_remove ) { if ( n_rows <= 1 ) { return NULL ; } int ** newMatrix = NULL ; newMatrix = allocMatrix ( n_rows - 1 , n_columns ); int orig_row = 0 ; for ( int i = 0 ; i < n_rows - 1 ; i ++ ) { for ( int j = 0 ; j < n_columns ; j ++ ) { orig_row = i < index_to_remove ? i : i - 1 ; * ( * ( newMatrix + i ) + j ) = * ( * ( matrix + orig_row ) + j ); } } return newMatrix ; } void freeMatrix ( int *** matrix , int n_rows ) { for ( int i = 0 ; i < n_rows ; i ++ ) { free ( * (( * matrix ) + i )); * (( * matrix ) + i ) = NULL ; } * matrix = NULL ; }","title":"Fichero: matrix.c"},{"location":"example/","text":"Ejercicio \u00b6 Para aprender a usar el depurador, vamos a implementar una aplicaci\u00f3n. Te sugerimos que pruebes a implementar todas las funciones indicadas del tir\u00f3n, sin probar la aplicaci\u00f3n en ning\u00fan momento. Info Implementar toda la l\u00f3gica de una aplicaci\u00f3n de golpe, sin hacer pruebas, no es la manera apropiada de programar y no es algo que aconsejemos. Pero en este caso lo que queremos es aumentar las probabilidades de que cometas alg\u00fan error para que puedas usar el depurador para encontrarlos. En el siguiente cap\u00edtulo, presentaremos una soluci\u00f3n (con errores), que ser\u00e1 la que usemos en el tutorial. M\u00e9todos \u00b6 allocMatrix \u00b6 1 2 3 4 5 6 /** * @param n_rows N\u00famero de filas * @param n_columns N\u00famero de columnas * @return Puntero a la matriz */ int ** allocMatrix ( int n_rows , int n_columns ); Reserva memoria din\u00e1mica para una matriz de dos dimensiones. fillMatrix \u00b6 1 2 3 4 5 6 /** * @param matrix Puntero a la matriz * @param n_rows N\u00famero de filas * @param n_columns N\u00famero de columnas */ void fillMatrix ( int ** matrix , int n_rows , int n_columns ); Rellena la matriz. Cada celda de coordenadas (x,y) ser\u00e1 el resultado de ejecutar la siguiente formula f(x,y) = -x + y . Es decir, la celda de coordenadas (0,0) dar\u00e1 como resultado f(0,0) = 0 y la de coordenadas (3,2) dar\u00e1 f(3,2) = -1 . printMatrix \u00b6 1 2 3 4 5 6 /** * @param matrix Puntero a la matriz * @param n_rows N\u00famero de filas * @param n_columns N\u00famero de columnas */ void printMatrix ( int ** matrix , int n_rows , int n_columns ); Imprime la matriz dada por la salida est\u00e1ndar. removeRow \u00b6 1 2 3 4 5 6 7 8 /** * @param matrix Puntero a la matriz * @param n_rows N\u00famero de filas * @param n_columns N\u00famero de columnas * @param index_to_remove \u00cdndice de la fila a borrar * @return Puntero a la nueva matriz */ int ** removeRow ( int ** matrix , int n_rows , int n_columns , int index_to_remove ); Hace una copia de la matrix indicada, pero eliminando una de las filas indicada por el \u00faltimo par\u00e1metro. freeMatrix \u00b6 1 2 3 4 5 /** * @param matrix Puntero a la matriz * @param n_rows N\u00famero de filas */ void freeMatrix ( int *** matrix , int n_rows ); Libera la memoria din\u00e1mica de la matriz indicada como par\u00e1metro y reinicia el puntero a NULL. Ejecuci\u00f3n del programa \u00b6 Crearemos una aplicaci\u00f3n que secuencialmente realice las siguientes acciones por orden (utilizando las funciones indicadas en la secci\u00f3n anterior): Reserve memoria para una matrix de 3x4. Rellene la matriz con la funci\u00f3n fillMatrix . Imprima la matriz por pantalla. Haga una copia eliminando la segunda fila con removeRow . Imprima la nueva matriz por pantalla. Libere la memoria de las dos matrices.","title":"Ejercicio"},{"location":"example/#ejercicio","text":"Para aprender a usar el depurador, vamos a implementar una aplicaci\u00f3n. Te sugerimos que pruebes a implementar todas las funciones indicadas del tir\u00f3n, sin probar la aplicaci\u00f3n en ning\u00fan momento. Info Implementar toda la l\u00f3gica de una aplicaci\u00f3n de golpe, sin hacer pruebas, no es la manera apropiada de programar y no es algo que aconsejemos. Pero en este caso lo que queremos es aumentar las probabilidades de que cometas alg\u00fan error para que puedas usar el depurador para encontrarlos. En el siguiente cap\u00edtulo, presentaremos una soluci\u00f3n (con errores), que ser\u00e1 la que usemos en el tutorial.","title":"Ejercicio"},{"location":"example/#metodos","text":"","title":"M\u00e9todos"},{"location":"example/#allocmatrix","text":"1 2 3 4 5 6 /** * @param n_rows N\u00famero de filas * @param n_columns N\u00famero de columnas * @return Puntero a la matriz */ int ** allocMatrix ( int n_rows , int n_columns ); Reserva memoria din\u00e1mica para una matriz de dos dimensiones.","title":"allocMatrix"},{"location":"example/#fillmatrix","text":"1 2 3 4 5 6 /** * @param matrix Puntero a la matriz * @param n_rows N\u00famero de filas * @param n_columns N\u00famero de columnas */ void fillMatrix ( int ** matrix , int n_rows , int n_columns ); Rellena la matriz. Cada celda de coordenadas (x,y) ser\u00e1 el resultado de ejecutar la siguiente formula f(x,y) = -x + y . Es decir, la celda de coordenadas (0,0) dar\u00e1 como resultado f(0,0) = 0 y la de coordenadas (3,2) dar\u00e1 f(3,2) = -1 .","title":"fillMatrix"},{"location":"example/#printmatrix","text":"1 2 3 4 5 6 /** * @param matrix Puntero a la matriz * @param n_rows N\u00famero de filas * @param n_columns N\u00famero de columnas */ void printMatrix ( int ** matrix , int n_rows , int n_columns ); Imprime la matriz dada por la salida est\u00e1ndar.","title":"printMatrix"},{"location":"example/#removerow","text":"1 2 3 4 5 6 7 8 /** * @param matrix Puntero a la matriz * @param n_rows N\u00famero de filas * @param n_columns N\u00famero de columnas * @param index_to_remove \u00cdndice de la fila a borrar * @return Puntero a la nueva matriz */ int ** removeRow ( int ** matrix , int n_rows , int n_columns , int index_to_remove ); Hace una copia de la matrix indicada, pero eliminando una de las filas indicada por el \u00faltimo par\u00e1metro.","title":"removeRow"},{"location":"example/#freematrix","text":"1 2 3 4 5 /** * @param matrix Puntero a la matriz * @param n_rows N\u00famero de filas */ void freeMatrix ( int *** matrix , int n_rows ); Libera la memoria din\u00e1mica de la matriz indicada como par\u00e1metro y reinicia el puntero a NULL.","title":"freeMatrix"},{"location":"example/#ejecucion-del-programa","text":"Crearemos una aplicaci\u00f3n que secuencialmente realice las siguientes acciones por orden (utilizando las funciones indicadas en la secci\u00f3n anterior): Reserve memoria para una matrix de 3x4. Rellene la matriz con la funci\u00f3n fillMatrix . Imprima la matriz por pantalla. Haga una copia eliminando la segunda fila con removeRow . Imprima la nueva matriz por pantalla. Libere la memoria de las dos matrices.","title":"Ejecuci\u00f3n del programa"},{"location":"print/","text":"Visualizar el estado de la aplicaci\u00f3n \u00b6 Ya tenemos localizado el error, que podemos ver en la l\u00ednea 5 de la figura anterior: el error se ha producido en la funci\u00f3n fillMatrix , que fue llamada con los valores de los par\u00e1metros indicados, y concretamente el fallo se ha producido en la l\u00ednea 47. Veamos el contexto del programa. Podemos ver el c\u00f3digo en nuestro editor o usar el comando list : 1 2 3 4 5 6 7 8 9 10 11 (gdb) list 47 42 { 43 for (int i = 0; i < n_rows; i++) 44 { 45 for (int j = 0; i < n_columns; j++) 46 { 47 *(*(matrix + i) + j) = - i + j; 48 } 49 } 50 } 51 Question \u00bfPuedes encontrar el error en ese bloque de c\u00f3digo? Int\u00e9ntalo antes de seguir leyendo. Estamos recorriendo una matriz, as\u00ed que el error m\u00e1s com\u00fan es un acceso fuera de rango. Necesitamos saber los valores de i y j . Para ver los valores de las variables podemos usar la orden print : 1 2 3 4 (gdb) print i $8 = 0 (gdb) print j $9 = 33612 Info Cuando necesitamos ver muchas variables, imprimir una a una puede ser un engorro, en ese caso podemos usar info locals para visualizar todas las variables del contexto en el que estamos: 1 2 3 (gdb) info locals j = 33612 i = 0 Hay m\u00e1s opciones como info args e info stack . Puedes verlas todas con help info . Lo tenemos, estamos cometiendo un error al iterar sobre j y se nos ha salido de rango. Revisando la aplicaci\u00f3n encontramos que el error est\u00e1 en la l\u00ednea 45, al comparar el l\u00edmite de j con el valor de i . Hacemos el siguiente cambio: 1 2 45- for (int j = 0; i < n_columns; j++) 45+ for (int j = 0; j < n_columns; j++) Salimos, volvemos a compilar y volvemos a probar, pero ya ejecutando siempre con gdb: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 (gdb) quit A debugging session is active. Inferior 1 [process 38009] will be killed. Quit anyway? (y or n) y $ gcc -g -o matrix matrix.c $ gdb -q matrix Reading symbols from matrix... (gdb) r Starting program: /home/sergio/Developer/aulasoftwarelibre/taller-de-gdb/example/matrix Matriz completa: Imprimiendo matrix... 0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 Hecho Matriz sin la segunda fila: Imprimiendo matrix... 0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 Hecho [Inferior 1 (process 38194) exited normally] (gdb) Comprobamos que ya no tenemos ning\u00fan error de segmentaci\u00f3n pero, sin embargo, la aplicaci\u00f3n no funciona como deber\u00eda. \u00bfC\u00f3mo encontramos el error ahora? Necesitamos analizar el funcionamiento de la aplicaci\u00f3n e ir viendo lo que hace conforme se ejecuta. Lo veremos en la siguiente secci\u00f3n.","title":"Visualizar el estado de la aplicaci\u00f3n"},{"location":"print/#visualizar-el-estado-de-la-aplicacion","text":"Ya tenemos localizado el error, que podemos ver en la l\u00ednea 5 de la figura anterior: el error se ha producido en la funci\u00f3n fillMatrix , que fue llamada con los valores de los par\u00e1metros indicados, y concretamente el fallo se ha producido en la l\u00ednea 47. Veamos el contexto del programa. Podemos ver el c\u00f3digo en nuestro editor o usar el comando list : 1 2 3 4 5 6 7 8 9 10 11 (gdb) list 47 42 { 43 for (int i = 0; i < n_rows; i++) 44 { 45 for (int j = 0; i < n_columns; j++) 46 { 47 *(*(matrix + i) + j) = - i + j; 48 } 49 } 50 } 51 Question \u00bfPuedes encontrar el error en ese bloque de c\u00f3digo? Int\u00e9ntalo antes de seguir leyendo. Estamos recorriendo una matriz, as\u00ed que el error m\u00e1s com\u00fan es un acceso fuera de rango. Necesitamos saber los valores de i y j . Para ver los valores de las variables podemos usar la orden print : 1 2 3 4 (gdb) print i $8 = 0 (gdb) print j $9 = 33612 Info Cuando necesitamos ver muchas variables, imprimir una a una puede ser un engorro, en ese caso podemos usar info locals para visualizar todas las variables del contexto en el que estamos: 1 2 3 (gdb) info locals j = 33612 i = 0 Hay m\u00e1s opciones como info args e info stack . Puedes verlas todas con help info . Lo tenemos, estamos cometiendo un error al iterar sobre j y se nos ha salido de rango. Revisando la aplicaci\u00f3n encontramos que el error est\u00e1 en la l\u00ednea 45, al comparar el l\u00edmite de j con el valor de i . Hacemos el siguiente cambio: 1 2 45- for (int j = 0; i < n_columns; j++) 45+ for (int j = 0; j < n_columns; j++) Salimos, volvemos a compilar y volvemos a probar, pero ya ejecutando siempre con gdb: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 (gdb) quit A debugging session is active. Inferior 1 [process 38009] will be killed. Quit anyway? (y or n) y $ gcc -g -o matrix matrix.c $ gdb -q matrix Reading symbols from matrix... (gdb) r Starting program: /home/sergio/Developer/aulasoftwarelibre/taller-de-gdb/example/matrix Matriz completa: Imprimiendo matrix... 0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 Hecho Matriz sin la segunda fila: Imprimiendo matrix... 0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 Hecho [Inferior 1 (process 38194) exited normally] (gdb) Comprobamos que ya no tenemos ning\u00fan error de segmentaci\u00f3n pero, sin embargo, la aplicaci\u00f3n no funciona como deber\u00eda. \u00bfC\u00f3mo encontramos el error ahora? Necesitamos analizar el funcionamiento de la aplicaci\u00f3n e ir viendo lo que hace conforme se ejecuta. Lo veremos en la siguiente secci\u00f3n.","title":"Visualizar el estado de la aplicaci\u00f3n"},{"location":"run/","text":"Compilar y ejecutar \u00b6 Vamos a compilar y ejecutar nuestra aplicaci\u00f3n con el compilador gcc: 1 2 3 $ gcc -o matrix matrix.c $ ./matrix [ 1 ] 14938 segmentation fault ( core dumped ) ./matrix Nuestra aplicaci\u00f3n tiene un error y ahora nos toca encontrarlo. Pero, \u00bfpor d\u00f3nde empezamos? Danger Un error muy com\u00fan entre principiantes es empezar a depurar usando printf para encontrar el momento en que la aplicaci\u00f3n falla. 1 2 3 printf(\"LLEGA 1\"); memcpy(a, b, 100); printf(\"LLEGA 2\"); El problema, adem\u00e1s de lo poco c\u00f3modo que es ir a\u00f1adiendo y borrando estas sentencias por toda la aplicaci\u00f3n, es que printf escribe en la salida est\u00e1ndar del sistema operativo. Esta salida tiene un buffer y es posible que la aplicaci\u00f3n falle antes de que se vac\u00ede y d\u00e9 la sensaci\u00f3n de que el error se ha producido antes de d\u00f3nde realmente tuvo lugar. Si realmente tienes la necesidad de depurar as\u00ed, usa la salida de error y no la est\u00e1ndar: 1 2 3 4 #include <stdio.h> fprintf(stderr, \"LLEGA 1\"); memcpy(a, b, 100); fprintf(stderr, \"LLEGA 2\"); La salida est\u00e1ndar de error no tiene buffer y el mensaje es inmediatamente impreso por consola. Gracias al depurador, podemos saber ex\u00e1ctamente en qu\u00e9 lugar y en qu\u00e9 condiciones se ha producido el error, con lo que no necesitamos usar t\u00e9cnicas de dudosa utilidad como printf . Para ello volvamos a compilar la aplicaci\u00f3n pero a\u00f1adiendo las marcas de depuraci\u00f3n y arrancaremos el depurador con nuestro ejecutable: 1 2 3 4 $ gcc -g -o matrix matrix.c $ gdb -q matrix Reading symbols from matrix... (gdb) El depurar ya est\u00e1 iniciado y est\u00e1 esperando \u00f3rdenes. A lo largo del tutorial iremos viendo las m\u00e1s \u00fatiles. Pero por el momento comenzaremos con la orden run , la cual permite iniciar la aplicaci\u00f3n: 1 2 3 4 5 6 (gdb) run Starting program: matrix Program received signal SIGSEGV, Segmentation fault. 0x0... in fillMatrix (matrix=0x55..., n_rows=5, n_columns=5) at matrix.c:47 47 *(*(matrix + i) + j) = - i + j; Tip Siempre que no haya ambiguedad, podemos abreviar los comandos usando las primeras letras. En el caso de run , podemos escribir r y el resultado es el mismo. Para otras \u00f3rdenes como m\u00ednimo habr\u00e1 que escribir dos o tres letras. El programa sigue fallando, pero esta vez tenemos informaci\u00f3n exacta de d\u00f3nde. Ahora tenemos que encontrar el error. Para eso necesitamos visualizar el estado de la aplicaci\u00f3n.","title":"Compilar y ejecutar"},{"location":"run/#compilar-y-ejecutar","text":"Vamos a compilar y ejecutar nuestra aplicaci\u00f3n con el compilador gcc: 1 2 3 $ gcc -o matrix matrix.c $ ./matrix [ 1 ] 14938 segmentation fault ( core dumped ) ./matrix Nuestra aplicaci\u00f3n tiene un error y ahora nos toca encontrarlo. Pero, \u00bfpor d\u00f3nde empezamos? Danger Un error muy com\u00fan entre principiantes es empezar a depurar usando printf para encontrar el momento en que la aplicaci\u00f3n falla. 1 2 3 printf(\"LLEGA 1\"); memcpy(a, b, 100); printf(\"LLEGA 2\"); El problema, adem\u00e1s de lo poco c\u00f3modo que es ir a\u00f1adiendo y borrando estas sentencias por toda la aplicaci\u00f3n, es que printf escribe en la salida est\u00e1ndar del sistema operativo. Esta salida tiene un buffer y es posible que la aplicaci\u00f3n falle antes de que se vac\u00ede y d\u00e9 la sensaci\u00f3n de que el error se ha producido antes de d\u00f3nde realmente tuvo lugar. Si realmente tienes la necesidad de depurar as\u00ed, usa la salida de error y no la est\u00e1ndar: 1 2 3 4 #include <stdio.h> fprintf(stderr, \"LLEGA 1\"); memcpy(a, b, 100); fprintf(stderr, \"LLEGA 2\"); La salida est\u00e1ndar de error no tiene buffer y el mensaje es inmediatamente impreso por consola. Gracias al depurador, podemos saber ex\u00e1ctamente en qu\u00e9 lugar y en qu\u00e9 condiciones se ha producido el error, con lo que no necesitamos usar t\u00e9cnicas de dudosa utilidad como printf . Para ello volvamos a compilar la aplicaci\u00f3n pero a\u00f1adiendo las marcas de depuraci\u00f3n y arrancaremos el depurador con nuestro ejecutable: 1 2 3 4 $ gcc -g -o matrix matrix.c $ gdb -q matrix Reading symbols from matrix... (gdb) El depurar ya est\u00e1 iniciado y est\u00e1 esperando \u00f3rdenes. A lo largo del tutorial iremos viendo las m\u00e1s \u00fatiles. Pero por el momento comenzaremos con la orden run , la cual permite iniciar la aplicaci\u00f3n: 1 2 3 4 5 6 (gdb) run Starting program: matrix Program received signal SIGSEGV, Segmentation fault. 0x0... in fillMatrix (matrix=0x55..., n_rows=5, n_columns=5) at matrix.c:47 47 *(*(matrix + i) + j) = - i + j; Tip Siempre que no haya ambiguedad, podemos abreviar los comandos usando las primeras letras. En el caso de run , podemos escribir r y el resultado es el mismo. Para otras \u00f3rdenes como m\u00ednimo habr\u00e1 que escribir dos o tres letras. El programa sigue fallando, pero esta vez tenemos informaci\u00f3n exacta de d\u00f3nde. Ahora tenemos que encontrar el error. Para eso necesitamos visualizar el estado de la aplicaci\u00f3n.","title":"Compilar y ejecutar"}]}